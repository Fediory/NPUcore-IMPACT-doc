\section{用户地址空间}
\begin{figure}[htb]
    \centering
    \includegraphics[width=\textwidth]{figures/figure1.pdf}
    \caption{
        用户虚拟地址空间示意
    }
    \label{fig:user virtual process}
\end{figure}
每一个进程都有一个独立的页表，当npucore实现进程切换的时候，对应的页表也会切换。

当一个用户进程通过系统调用向操作系统请求更多的用户空间时，npucore首先在os/src/frame_allocator.rs中的StackFrameAllocator的基于栈的数据结构实现空闲物理页的分配，然后将物理页的映射加入到用户的页表当中。
npucore将设置PTEflags::R，PTEflags::W，PTEflags::U，PTEflags::X以及PTEflags::V标志位到对应的页表项目，使得用户可以对分配的页面进行读写操作。
大多数的用户进程并不能完全利用所有的虚拟空间，对于没有用到的空间，它对应的页表项PTEflags::V标志位始终为0。

页表的设计有很多的好处。首先，首先不同的进程使用不同的页表，相同的虚拟地址映射到不同的物理地址，因此每一个进程可以拥有自己独立的内存空间。其次，用户的虚拟地址是连续的，对应的物理地址不一定是连续的，这样可以有效的避免内存碎片。最后，内核将所有的用户的跳板代码都映射到了同一段虚地址，可以有效的实现上下文切换。

如图\ref{fig:user virtual process}所示，用户的虚拟地址空间被分为了三个部分，分别是用户代码段，用户数据段以及用户堆栈段。用户代码段用于存放用户的代码，用户数据段用于存放用户的数据，用户堆栈段用于存放用户的堆栈。
其中，用户栈的初始内容如图中所示，由execve函数完成初始化，其中包含了用户的命令行参数和返回地址，紧接着就是main函数使用的栈空间。

npucore实现了execve来将elf文件加载到内存的进程地址空间中，实现了sbrk来动态的分配用户空间，实现了mmap来将文件映射到用户空间，实现了munmap来取消文件的映射。

\subsection{sbrk系统调用}
sbrk系统调用是早期的Unix系统中的一个系统调用，用于动态的分配用户空间。sbrk系统调用的原型如下：
\begin{lstlisting}[language=c]
    void *sbrk(intptr_t increment);
\end{lstlisting}
sbrk系统调用将堆的大小增加increment字节，并返回堆的起始地址。
如果increment为负数，则堆的大小减少increment字节。如果堆的大小超过了进程的地址空间，则sbrk系统调用返回-1，并设置errno为ENOMEM。
sbrk系统调用可以为一个进程扩大或者缩小堆的大小，主要的实现是由os/src/memory_set.rs中的sbrk函数完成。
sbrk函数调用Memoryset::mmap或者Memoryset::munmap来实现堆的扩大或者缩小。
mmap函数不仅用于sbrk系统调用，还用于mmap系统调用，用于将文件映射到用户空间和开辟匿名内存映射。
\begin{lstlisting}[language=rust]
    pub fn sbrk(&mut self, heap_pt: usize, heap_bottom: usize, increment: isize) -> usize {
        let old_pt: usize = heap_pt;
        let new_pt: usize = old_pt + increment as usize;
        // 判断扩大堆还是缩小堆
        if increment > 0 {
            let limit = heap_bottom + USER_HEAP_SIZE;
            if new_pt > limit {
                return old_pt;
            } else {
                self.mmap(
                    old_pt,
                    increment as usize,
                    MapPermission::R | MapPermission::W | MapPermission::U,
                    MapFlags::MAP_ANONYMOUS | MapFlags::MAP_FIXED | MapFlags::MAP_PRIVATE,
                    1usize.wrapping_neg(),
                    0,
                );
                trace!("[sbrk] heap area expanded to {:X}", new_pt);
            }
        } else if increment < 0 {
            // 如果缩小后的堆地址小于堆底地址，则不进行缩小
            if new_pt <= heap_bottom {
                return old_pt;
            } else {
                self.munmap(old_pt, increment as usize).unwrap();
            }
        }
        new_pt
    }
\end{lstlisting}