\section{buffer cache层}
文件系统中的块缓存层（Buffer Cache）扮演着非常重要的角色，主要目的是提高文件系统性能和效率。以下是块缓存层的几个关键作用：

1.减少磁盘I/O操作：块缓存层通过在内存中缓存最近或频繁访问的磁盘块来减少对磁盘的直接访问。这是因为内存访问速度远快于磁盘。

2.加速数据访问：当应用程序请求数据时，操作系统首先在块缓存中查找。如果找到所需的数据块，就可以直接从内存中读取，而无需等待磁盘的慢速读取。

3.合并写操作：写操作经常被先写入到块缓存中，并在稍后的某个时刻一起写入磁盘。这种方式可以合并多个小的写操作为一个大的磁盘I/O操作，提高写入效率。

4.减少重复数据读取：如果多个应用或进程读取相同的数据块，这些数据块只需要从磁盘读取一次，之后可以从块缓存中获取，减少了重复的磁盘访问。

5.提供一致性和同步机制：块缓存可以保证文件系统中数据的一致性。例如，在崩溃恢复期间，它可以帮助恢复未完成的写操作，确保文件系统的完整性。

6.支持异步写操作：数据可以先缓存在块缓存中，然后异步地写入磁盘。这允许程序继续执行而不必等待磁盘I/O操作完成。

7.减轻磁盘的负载：通过减少对磁盘的访问次数，块缓存有助于降低磁盘的工作负载，延长其使用寿命。
\\[10pt]

Npucore中对于文件系统同样实现了buff cache层，其主要定义于easy-fs/src/block_cache.rs文件中。

首先是对于整个块缓存的定义：
\begin{lstlisting}[language={Rust},caption={Cache缓存对象基本操作}]
    pub trait Cache {

    fn read<T, V>(&self, offset: usize, f: impl FnOnce(&T) -> V) -> V;

    fn modify<T, V>(&mut self, offset: usize, f: impl FnOnce(\&mut T) -> V) -> V;

    fn sync(&self, _block_ids: Vec<usize>, _block_device: &Arc<dyn BlockDevice>) {}
}
\end{lstlisting}
这个 trait 定义了一个缓存对象的基本操作。

read<T, V>(\&self, offset: usize, f: impl FnOnce(\&T) -> V) -> V: 允许以只读方式访问缓存。它接受一个偏移量和一个闭包 f，闭包作用于缓存中的数据，并返回一个结果。这是一个泛型函数，支持不同类型的数据。

modify<T, V>(\&mut self, offset: usize, f: impl FnOnce(\&mut T) -> V) -> V: 类似于 read，但用于可变地修改缓存。它也接受一个偏移量和一个闭包，但闭包可以修改数据。


sync(\&self, _block_ids: Vec<usize>, _block_device: \&Arc<dyn BlockDevice>): 将缓存中的数据写回到磁盘。接受一个块ID列表和一个指向块设备的引用。
\\[10pt]

为了更好的管理缓存空间，我们需要实现一个CacheManager对于缓存进行更好的管理，第一点是可以统一管理不同类型的缓存，如块缓存和页表缓存，其次可以实现资源管理和性能优化，npucore中对oom的具体实现的是综合了引用计数和优先级两种策略的方法，这有助于提高系统的整体性能，减少磁盘I/O操作。

\begin{lstlisting}[language={Rust},caption={CacheManager的实现}]
    pub trait CacheManager {
    /// The constant to mark the cache size.
    const CACHE_SZ: usize;

    type CacheType: Cache;

    /// Constructor to the struct.
    fn new() -> Self
    where
        Self: Sized;
    /// Tell cache manager to write back cache and release memory
    /// Argument：
    /// 'neighbor': A closure to get block ids when cache miss.
    /// 'block_device': The pointer to the block_device.
    /// Return Value：
    /// Number of caches freed
    fn oom<FUNC>(
        &self,
        _neighbor: FUNC,
        _block_device: &Arc<dyn BlockDevice>
    ) -> usize
    where
        FUNC: Fn(usize) -> Vec<usize>
    {
        unreachable!()
    }
    /// When file size changed, we should notify cache manager to drop some cache
    /// Argument：
    /// 'new_size': File's new size
    fn notify_new_size(
        &self,
        _new_size: usize
    ) {
        unreachable!()
    }
}
\end{lstlisting}
这个 trait 定义了缓存管理器的基本功能。

new() -> Self: 静态方法，用于创建一个新的缓存管理器实例。

oom<FUNC>(\&self, _neighbor: FUNC, _block_device: \&Arc<dyn BlockDevice>) -> usize: 当系统内存不足时，释放一些缓存。接受一个邻居闭包来获取块ID，以及一个指向块设备的引用。

notify_new_size(\&self, _new_size: usize): 当文件大小变化时，通知缓存管理器释放⼀些缓存块
\\[10pt]

然后就是对于缓存管理的分别具体实现，因为我们有块缓存和页缓存两种缓存块，所以我们这里分别对CacheManager进一步封装实现了BlockCacheManager和PageManager：

\begin{lstlisting}[language={Rust},caption={BCM和CM}]
    pub trait BlockCacheManager: CacheManager {
    /// Try to get the block cache and return `None` if not found.
    /// Argument：
    /// 'block_id': The demanded block id(for block cache).
    /// 'inner_cache_id': The ordinal number of the cache inside the file(for page cache).
    /// Return Value：
    /// If found, return Some(pointer to cache)
    /// otherwise, return None
    fn try_get_block_cache(
        &self,
        block_id: usize,
    ) -> Option<Arc<Mutex<Self::CacheType>>>;

    /// Attempt to get block cache from the cache.
    /// If failed, the manager should try to copy the block from sdcard.
    /// Argument：
    /// 'block_id': The demanded block id(for block cache).
    /// 'inner_cache_id': The ordinal number of the cache inside the file(for page cache).
    /// 'neighbor': A closure to get block ids when cache miss.
    /// 'block_device': The pointer to the block_device.
    /// Return Value：
    /// Pointer to cache
    fn get_block_cache<FUNC>(
        &self,
        block_id: usize,
        block_device: &Arc<dyn BlockDevice>,
    ) -> Arc<Mutex<Self::CacheType>>;
}
\end{lstlisting}

try_get_block_cache 该函数尝试获取传⼊参数 block_id （磁盘编号）和 inner_cache_id （管理器内部编号）对应的 Cache。  

get_block_cache 该函数获取传⼊参数 block_id （磁盘编号）和 inner_cache_id （管理器内部编号）对应的 Cache 。如果内存中没有，则会通过 block_device 从块设备中读⼊对应的内容：

\begin{lstlisting}[language={Rust},caption={PageCacheManager}]
    pub trait PageCacheManager: CacheManager {
    /// Try to get the block cache and return `None` if not found.
    /// Argument：
    /// 'block_id': The demanded block id(for block cache).
    /// 'inner_cache_id': The ordinal number of the cache inside the file(for page cache).
    /// Return Value：
    /// If found, return Some(pointer to cache)
    /// otherwise, return None
    fn try_get_page_cache(
        &self,
        inner_cache_id: usize,
    ) -> Option<Arc<Mutex<Self::CacheType>>>;

    /// Attempt to get block cache from the cache.
    /// If failed, the manager should try to copy the block from sdcard.
    /// Argument：
    /// 'block_id': The demanded block id(for block cache).
    /// 'inner_cache_id': The ordinal number of the cache inside the file(for page cache).
    /// 'neighbor': A closure to get block ids when cache miss.
    /// 'block_device': The pointer to the block_device.
    /// Return Value：
    /// Pointer to cache
    fn get_page_cache<FUNC>(
        &self,
        inner_id: usize,
        neighbor: FUNC,
        block_device: &Arc<dyn BlockDevice>,
    ) -> Arc<Mutex<Self::CacheType>>
    where
        FUNC: Fn() -> Vec<usize>;
}
\end{lstlisting}
其中两个方法和BlockCacheManager中两个方法的实现是一样的，唯一区别在于两个管理的cache（大小）不同。


