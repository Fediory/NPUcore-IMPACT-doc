\chapter{理解文件系统}




\section{文件系统概述}
文件最早来自于计算机用户需要把数据持久保存在 持久存储设备上的需求。由于放在内存中的数据在计算机关机或掉电后就会消失，所以应用程序要把内存中需要保存的数据放到 持久存储设备的数据块（比如磁盘的扇区等）中存起来。随着操作系统功能的增强，在操作系统的管理下，应用程序不用理解持久存储设备的硬件细节，而只需对文件这种持久存储数据的抽象进行读写就可以了，由操作系统中的文件系统和存储设备驱动程序一起来完成繁琐的持久存储设备的管理与读写。所以本章要完成的操作系统的第一个核心目标是： 让应用能够方便地把数据持久保存起来 。

对于应用程序访问持久存储设备的需求，内核需要新增两种文件：常规文件和目录文件，它们均以文件系统所维护的磁盘文件形式被组织并保存在持久存储设备上。

这里简要介绍一下在内核中添加文件系统的大致开发过程。

\textbf{第一步：是能够写出与文件访问相关的应用}

这里是参考了Linux的创建/打开/读写/关闭文件的系统调用接口，力图实现一个简化版的文件系统模型 。在用户态我们只需要遵从相关系统调用的接口约定，在用户库里完成对应的封装即可。

\textbf{第二步：实现 easyfs 文件系统}

由于 Rust 语言的特点，我们可以在用户态实现文件系统，并在用户态完成文件系统功能的基本测试并基本验证其实现正确性之后，就可以放心的将该模块嵌入到操作系统内核中。当然，有了文件系统的具体实现，还需要对上一章的操作系统内核进行扩展，实现文件系统对接的接口，这样才可以让操作系统拥有一个简单可用的文件系统。这样内核就可以支持具有文件读写功能的复杂应用。当内核进一步支持应用的命令行参数后，就可以进一步提升应用程序的灵活性，让应用的开发和调试变得更为轻松。
文件系统的整体架构自下而上可分为五层：
\begin{itemize}
    \item 磁盘块设备接口层：读写磁盘块设备的trait接口
    \item 块缓存层：位于内存的磁盘块数据缓存
    \item 磁盘数据结构层：表示磁盘文件系统的数据结构
    \item 磁盘块管理器层：实现对磁盘文件系统的管理
    \item 索引节点层：实现文件创建/文件打开/文件读写等操作
\end{itemize}
它的最底层就是对块设备的访问操作接口。两个函数 read\_block 和 write\_block ，分别代表将数据从块设备读到内存缓冲区中，或者将数据从内存缓冲区写回到块设备中，数据需要以块为单位进行读写。

尽管在操作系统的最底层（即块设备驱动程序）已经有了对块设备的读写能力，但从编程方便/正确性和读写性能的角度来看，仅有块读写这么基础的底层接口是不足以实现高效的文件系统。比如，某应用将一个块的内容读到内存缓冲区，对缓冲区进行修改，并尚未写回块设备时，如果另外一个应用再次将该块的内容读到另一个缓冲区，而不是使用已有的缓冲区，这将会造成数据不一致问题。此外还有可能增加很多不必要的块读写次数，大幅降低文件系统的性能。因此，通过程序自动而非程序员手动地对块缓冲区进行统一管理也就很必要了，该机制被我们抽象为第二层，即块缓存层。

有了块缓存，我们就可以在内存中方便地处理文件系统在磁盘上的各种数据了，这就是第三层文件系统的磁盘数据结构。

文件系统中的所有需要持久保存的数据都会放到磁盘上，这包括了管理这个文件系统的 超级块 (Super Block)，管理空闲磁盘块的索引节点位图区和数据块位图区 ，以及管理文件的索引节点区和放置文件数据的数据块区组成。文件系统中管理这些磁盘数据的控制逻辑主要集中在磁盘块管理器中，这是文件系统的第四层。

对于单个文件的管理和读写的控制逻辑主要是 索引节点（文件控制块） 来完成，这是文件系统的第五层。

\textbf{第三步：把easyfs文件系统加入内核中}

这还需要做两件事情，第一件是在Qemu模拟的 virtio 块设备上实现块设备驱动程序 。由于我们可以直接使用 virtio-drivers crate中的块设备驱动，所以只要提供这个块设备驱动所需要的内存申请与释放以及虚实地址转换的4个函数就可以了。而我们之前操作系统中的虚存管理实现中，已经有这些函数，这使得块设备驱动程序很简单，且具体实现细节都被 virtio-drivers crate封装好了。

第二件事情是把文件访问相关的系统调用与easyfs文件系统连接起来。在easfs文件系统中是没有进程的概念的。而进程是程序运行过程中访问资源的管理实体，而之前的进程没有管理文件这种资源。 为此我们需要扩展进程的管理范围，把文件也纳入到进程的管理之中。 由于我们希望多个进程都能访问文件，这意味着文件有着共享的天然属性，这样自然就有了open/close/read/write这样的系统调用，便于进程通过互斥或共享方式访问文件。

内核中的进程看到的文件应该是一个便于访问的Inode，这就要对Inode 结构进一步封装，形成 OSInode 结构，以表示进程中一个打开的常规文件。而进程为了进一步管理多个文件，需要扩展文件描述符表。这样进程通过系统调用打开一个文件后，会将文件加入到自身的文件描述符表中，并进一步通过文件描述符（也就是某个特定文件在自身文件描述符表中的下标）来读写该文件。对于应用程序而言，它理解的磁盘数据是常规的文件和目录，不是 OSInode 这样相对复杂的结构。其实常规文件对应的 OSInode 是操作系统内核中的文件控制块数据结构的实例，它实现了 File Trait 定义的函数接口。这些 OSInode 实例会放入到进程文件描述符表中，并通过 sys\_read/write 系统调用来完成读写文件的服务。这样就建立了文件与 OSInode 的对应关系，通过上面描述的三个开发步骤将形成包含文件系统的操作系统内核，可给应用提供基于文件的系统调用服务。
