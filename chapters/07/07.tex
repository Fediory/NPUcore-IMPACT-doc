\section{文件相关系统调用}
npucore实现了许多POSIX规定的系统调用，本章主要介绍几个与文件相关的系统调用，包括文件的创建、打开、关闭、读写、删除等。
\subsection{write}
对于文件的读是最常使用的系统调用之一，包括输入输出都是基于终端来实现的（终端本身也可以当作一个文件）。
下面我们来介绍npucore中write的实现。

write系统调用的函数签名如下：
\begin{lstlisting}[language={C}]
int write(int fd, const void *buf, size_t count);
\end{lstlisting}
write系统调用将buf中的count个字节写入文件描述符fd所指向的文件中。成功时返回写入的字节数，失败时返回-1。

NPUCore中的代码实现如下：
\begin{lstlisting}[language={Rust}, label={lst:write}]
pub fn sys_write(fd: usize, buf: usize, count: usize) -> isize {
    let task = current_task().unwrap();
    let fd_table = task.files.lock();
    let file_descriptor = match fd_table.get_ref(fd) {
        Ok(file_descriptor) => file_descriptor,
        Err(errno) => return errno,
    };
    if !file_descriptor.writable() {
        return EBADF;
    }
    let token = task.get_user_token();
    file_descriptor.write_user(
        None,
        UserBuffer::new({
            match translated_byte_buffer(token, buf as *const u8, count) {
                Ok(buffer) => buffer,
                Err(errno) => return errno,
            }
        }),
    ) as isize
}
\end{lstlisting}
其逐代码块的解释如下：
current_task().unwrap() 获取当前任务（线程）的引用。
task.files.lock() 获取当前任务的文件表的锁，以确保并发访问的同步。
通过文件描述符 fd 从文件表中获取文件描述符的引用，使用 fd_table.get_ref(fd)。如果获取失败，则返回相应的错误号。
检查文件是否可写，如果不可写则返回 EBADF 错误号。
获取当前任务的用户令牌，通常用于在用户空间和内核空间之间传递数据。
将用户空间缓冲区的数据写入文件描述符。这里使用了 translated_byte_buffer 函数来将用户空间的字节缓冲区翻译成内核地址空间，确保正确的内存访问。
最后，将写入的字节数作为 isize 类型返回。

如果从代码的逻辑层次来分析，其调用过程如下：

sys_writet。获取当前进程的引用，然后获取文件描述符表，然后根据该表与参数fd获取对相应文件描述符的引用。这之后检查文件是否可写并获取user_token，这些操作都完成之后，以buffer（缓冲区）与count（缓冲区长度）两个参数转换为buffer，传入FileDescriptor::write_user中。

FileDescriptor::write_user。直接调用<dyn File>的write_user函数

OSInode::write_user。如果参数中offset为none（比如由write系统调用时就为none），则先获取文件偏移的锁、inode（OSInode中inner）的锁，然后看是否设置了追加标志，如果是，则将文件偏移放到最后（即从文件末尾开始写入）。然后调用OSInode.inner的write_at_block_cache_lock（即Inode::write_at_block_cache_lock）。完成之后，修改记录的文件偏移，返回写入的字节数。

Inode::write_at_block_cache_lock。内部有一个loop，计算块的末尾、写入并更新大小、移动到下一个块。到这里，写入过程就结束了。然而此时数据仍然留在内存中，还没有被持久化。被持久化的过程是另一个独立的过程，将在IO设备章节详细介绍。在这里做一个简要讲解：当满足某个条件时（比如缓冲区接近满溢），应当调用OSInode的oom函数，将满足条件的缓冲块落盘。


\subsection{read}
read函数用于从文件描述符中读取数据，并将数据存储到缓冲区中。这个系统调用在应用程序与操作系统内核之间搭建了一座桥梁，允许应用程序从指定的文件描述符中读取数据。以下是read系统调用的工作流程。

调用请求：应用程序通过执行read系统调用，并传入相应的文件描述符、缓冲区地址和要读取的字节数，发起读取请求。

参数验证：内核首先验证参数的有效性，包括文件描述符的合法性和缓冲区地址的可访问性。

读取操作：内核根据文件描述符找到相应的文件或数据流，并从中读取指定数量的字节。这个过程可能涉及文件系统的访问、网络操作或设备交互。

数据传输：读取的数据被存储在内核缓冲区中，然后被复制到用户提供的缓冲区。这个过程涉及从内核空间到用户空间的数据传输。

返回结果：read调用最终返回读取的字节数。如果到达文件末尾，则返回0。如果发生错误，则返回一个负值，并设置相应的错误码。

阻塞与非阻塞模式：read操作可以在阻塞或非阻塞模式下进行。在阻塞模式下，如果没有可用数据，read调用会阻塞调用进程，直到有数据可读。在非阻塞模式下，如果没有数据可读，read会立即返回，通常是一个错误码。

接下来是在NPUCore中read的具体实现：

\begin{lstlisting}[language=rust]
pub fn sys_read(fd: usize, buf: usize, count: usize) -> isize {
    let task = current_task().unwrap();
    let fd_table = task.files.lock();
    let file_descriptor = match fd_table.get_ref(fd) {
        Ok(file_descriptor) => file_descriptor,
        Err(errno) => return errno,
    };
    // fd is not open for reading
    if !file_descriptor.readable() {
        return EBADF;
    }
    let token = task.get_user_token();
    file_descriptor.read_user(
        None,
        UserBuffer::new({
            match translated_byte_buffer(token, buf as *const u8, count) {
                Ok(buffer) => buffer,
                Err(errno) => return errno,
            }
        }),
    ) as isize
}
\end{lstlisting}

获取当前任务：函数首先获取当前正在执行的任务或进程的上下文。

获取文件描述符表：锁定当前任务的文件描述符表，并尝试从中获取与传入的文件描述符fd相对应的文件描述符对象。

错误处理：如果指定的文件描述符不存在或其他错误发生，函数将返回相应的错误码。

检查读取权限：确认获取到的文件描述符是否具有读取权限。如果没有，返回EBADF错误码，表示文件描述符不合法或不支持读取操作。

获取用户令牌：获取与当前任务关联的用户令牌，用于后续的权限验证和内存安全检查。

处理用户缓冲区：使用$translated\_byte\_buffer$函数将用户空间的缓冲区地址和长度转换为内核可以操作的缓冲区对象UserBuffer。这一步骤涉及内存地址转换和错误检查。

执行读取操作：调用文件描述符的$read\_user$方法，从文件或数据流中读取数据到用户提供的缓冲区中。

返回结果：返回从文件描述符中实际读取的字节数。如果读取过程中发生错误，返回相应的错误码。

\subsection{open}
首先，我们分析一下NPUcore文件系统提供给应用的接口，即用户态的sys_open 系统调用。

在读写一个常规文件之前，应用首先需要通过内核提供的 sys_open 系统调用让该文件在进程的文件描述符表中占一项，并得到操作系统的返回值——文件描述符，即文件关联的表项在文件描述表中的索引值：
\begin{lstlisting}[language=rust]
// user/src/syscall.rs
/// syscall ID：56
pub fn sys_open(path: &str, flags: u32) -> isize {
	syscall(SYSCALL_OPEN, [path.as_ptr() as usize, flags as usize, 0])
}
\end{lstlisting}

如上所示 sys_open 的功能为打开一个常规文件，并返回可以访问它的文件描述符。参数path描述要打开的文件的文件名（简单起见，文件系统不需要支持目录，所有的文件都放在根目录 / 下），flags 描述打开文件的标志，具体含义下面给出。至于返回值，如果出现了错误则返回 -1，否则返回打开常规文件的文件描述符。可能的错误原因是：文件不存在。

然后我们讲解一下flags，目前我们的内核支持以下几种标志（多种不同标志可能共存）：
\begin{itemize}
\item [$\bullet$]
如果 flags 为 0，则表示以只读模式 RDONLY 打开；
\item [$\bullet$]
如果 flags 第 0 位被设置（0x001），表示以只写模式 WRONLY 打开；
\item [$\bullet$]
如果 flags 第 1 位被设置（0x002），表示既可读又可写 RDWR ；
\item [$\bullet$]
如果 flags 第 9 位被设置（0x200），表示允许创建文件 CREATE ，在找不到该文件的时候应创建文件；如果该文件已经存在则应该将该文件的大小归零；
\item [$\bullet$]
如果 flags 第 10 位被设置（0x400），则在打开文件的时候应该清空文件的内容并将该文件的大小归零，也即 TRUNC 。
\end{itemize}

注意 flags 里面的权限设置只能控制进程对本次打开的文件的访问。一般情况下，在打开文件的时候首先需要经过文件系统的权限检查，比如一个文件自身不允许写入，那么进程自然也就不能以 WRONLY 或 RDWR 标志打开文件。但在我们简化版的文件系统中文件不进行权限设置，这一步就可以绕过。

在用户库 user_lib 中，我们将该系统调用封装为 open 接口：
\begin{lstlisting}[language=rust]
	// user/src/lib.rs
	
	bitflags! {
		pub struct OpenFlags: u32 {
			const RDONLY = 0;
			const WRONLY = 1 << 0;
			const RDWR = 1 << 1;
			const CREATE = 1 << 9;
			const TRUNC = 1 << 10;
		}
	}
	
	pub fn open(path: &str, flags: OpenFlags) -> isize {
		sys_open(path, flags.bits)
	}
\end{lstlisting}

如上，借助 bitflags! 宏我们将一个 u32 的 flags 包装为一个 OpenFlags 结构体更易使用，它的 bits 字段可以将自身转回 u32 ，它也会被传给 sys_open。
\begin{lstlisting}[language=rust]
	// user/src/syscall.rs
	/// syscall ID：56
	pub fn sys_open(path: &str, flags: u32) -> isize {
		syscall(SYSCALL_OPEN, [path.as_ptr() as usize, flags as usize, 0])
	}
\end{lstlisting}

如上，sys_open 传给内核的参数只有待打开文件的文件名字符串的起始地址（和之前一样，我们需要保证该字符串以 $\backslash$0 结尾）还有标志位。由于每个通用寄存器为 64 位，我们需要先将 u32 的 flags 转换为 usize 。

接下来，我们分析一下 sys_open 在内核中的实现。


\subsection{close}
首先，我们分析一下NPUcore文件系统提供给应用的接口，即用户态的 sys_close 系统调用。

在打开文件，对文件完成了读写操作后，还需要关闭文件，这样才让进程释放被这个文件占用的内核资源。 close 的调用参数是文件描述符，当文件被关闭后，该文件在内核中的资源会被释放，文件描述符会被回收。这样，进程就不能继续使用该文件描述符进行文件读写了。
\begin{lstlisting}[language=rust]
	// usr/src/lib.rs
	pub fn close(fd: usize) -> isize { sys_close(fd) }
	
	// user/src/syscall.rs
	const SYSCALL_CLOSE: usize = 57;
	
	pub fn sys_close(fd: usize) -> isize {
		syscall(SYSCALL_CLOSE, [fd, 0, 0])
	}
\end{lstlisting}

如上，sys_close 的功能是当前进程关闭一个文件，参数 fd 表示要关闭的文件的文件描述符，如果成功关闭则返回 0 ，否则返回 -1 。可能的出错原因：传入的文件描述符并不对应一个打开的文件。

接下来，我们分析一下 sys_open 在内核中的实现。

关闭文件的系统调用 sys_close 实现非常简单，我们只需将进程控制块中的文件描述符表对应的一项改为 None 代表它已经空闲即可，同时这也会导致内层的引用计数类型 Arc 被销毁，会减少一个文件的引用计数，当引用计数减少到 0 之后文件所占用的资源就会被自动回收。
\begin{lstlisting}[language=rust]
	pub fn sys_close(fd: usize) -> isize {
		info!("[sys_close] fd: {}", fd);
		let task = current_task().unwrap();
		let mut fd_table = task.files.lock();
		match fd_table.remove(fd) {
			Ok(_) => SUCCESS,
			Err(errno) => errno,
		}
	}
\end{lstlisting}

\subsection{fstat,fstatat}
NPUcore为用户提供了fstat和fstatat两个系统调用用于获取文件信息。相比之下，fstatat的功能更加完善和丰富，实现也更加复杂，这里先从fstatat开始分析。

fstatat和fstat的函数原型如下：

\begin{lstlisting}[language={Rust}, label={code:fstat,fstatat},
	caption={fstat,fstatat}]
	pub fn sys_fstatat(dirfd: usize, path: *const u8, buf: *mut u8, flags: u32) -> isize {}
	pub fn sys_fstat(fd: usize, statbuf: *mut u8) -> isize {}
		
\end{lstlisting}

从参数可以看出，statat可以按照路劲访问文件信息，而fstat则只能通过进程的文件描述符表访问。这是两者的主要区别。
对于fstat，首先进行的是获取当前进程信息以及解析路径：

\begin{lstlisting}[language={Rust}, label={code:fstatat part1},
	caption={fstatat_part1}]
    let token = current_user_token();
let path = match translated_str(token, path) {
	Ok(path) => path,
	Err(errno) => return errno,
};
let flags = match FstatatFlags::from_bits(flags) {
	Some(flags) => flags,
	None => {
		warn!("[sys_fstatat] unknown flags");
		return EINVAL;
	}
};

info!(
"[sys_fstatat] dirfd: {}, path: {:?}, flags: {:?}",
dirfd as isize, path, flags,
);

let task = current_task().unwrap();
	
\end{lstlisting}

flags这里只是进行了解析，但是在之后实现中没有涉及，这里也不过多叙述。在这里获取了当前运行的进程，并且将切片类型的path映射到当前地址空间，并且转换成string类型。

\begin{lstlisting}[language={Rust}, label={code:fstatat part2},
	caption={fstatat_part2}]
let file_descriptor = match dirfd {
	AT_FDCWD => task.fs.lock().working_inode.as_ref().clone(),
	fd => {
		let fd_table = task.files.lock();
		match fd_table.get_ref(fd) {
			Ok(file_descriptor) => file_descriptor.clone(),
			Err(errno) => return errno,
		}
	}
};

match file_descriptor.open(&path, OpenFlags::O_RDONLY, false) {
	Ok(file_descriptor) => {
		copy_to_user(token, &file_descriptor.get_stat(), buf as *mut Stat);
		SUCCESS
	}
	Err(errno) => errno,
}
\end{lstlisting}

这里先获取当前目录的文件描述符，之后调用open函数通过路径打开文件。如果文件打开成功，则调用copy_to_user函数将文件信息内容拷贝到buf中，之后函数返回。

对于文件信息的内容，NPUcore中使用结构体Stat表示，具体代码如下：
\begin{lstlisting}[language={Rust}, label={code:Stat},
	caption={Stat}]
#[derive(Clone, Copy, Debug)]
#[repr(C)]
/// Store the file attributes from a supported file.
pub struct Stat {
	/// ID of device containing file
	st_dev: u64,
	/// Inode number
	st_ino: u64,
	/// File type and mode   
	st_mode: u32,
	/// Number of hard links
	st_nlink: u32,
	/// User ID of the file's owner.
	st_uid: u32,
	/// Group ID of the file's group.
	st_gid: u32,
	/// Device ID (if special file)
	st_rdev: u64,
	__pad: u64,
	/// Size of file, in bytes.
	st_size: i64,
	/// Optimal block size for I/O.
	st_blksize: u32,
	__pad2: i32,
	/// Number 512-byte blocks allocated.
	st_blocks: u64,
	/// Backward compatibility. Used for time of last access.
	st_atime: TimeSpec,
	/// Time of last modification.
	st_mtime: TimeSpec,
	/// Time of last status change.
	st_ctime: TimeSpec,
	__unused: u64,
}
\end{lstlisting}

结构体每一个字段的含义已经给出。

对于系统调用fstat，其功能相较于fstatat更为简单。仅仅只有通过进程的文件描述符表获取文件描述符和相关信息的拷贝。具体代码如下：

\begin{lstlisting}[language={Rust}, label={code:fstat},
	caption={fstat}]
pub fn sys_fstat(fd: usize, statbuf: *mut u8) -> isize {
	let task = current_task().unwrap();
	let token = task.get_user_token();
	
	info!("[sys_fstat] fd: {}", fd);
	let file_descriptor = match fd {
		AT_FDCWD => task.fs.lock().working_inode.as_ref().clone(),
		fd => {
			let fd_table = task.files.lock();
			match fd_table.get_ref(fd) {
				Ok(file_descriptor) => file_descriptor.clone(),
				Err(errno) => return errno,
			}
		}
	};
	copy_to_user(token, &file_descriptor.get_stat(), statbuf as *mut Stat);
	SUCCESS
}
\end{lstlisting}

由于其本身传入参数的限制，fstat函数只能获取当前进程的文件信息。