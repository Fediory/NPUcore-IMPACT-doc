\chapter{NPUcore简介(Introduction)}

“NPUcore”是西北工业大学的操作系统内核构建实践型教学操作系统，曾获得2022年OSKernel大赛内核实现赛道一等奖。
NPUcore致力于使用Rust新型编程语言，帮助老师和学生自行研制一个操作系统微型内核，提升操作系统原理的实践体验并探索新型操作系统的设计与实现。
原始的2022版NPUcore具有内存管理、进程管理、文件系统核心系统调用功能，支持RISCV32/64指令集，可在对应的QEMU模拟器和SiFive-U740、K210等嵌入式开发板上运行。
该版本基于rCore-Tutorial迭代开发，重构90\%模块以支持Linux接口，共实现系统调用81个，是一个不错的baseline。
虽然该版本有着不错的性能，但却无法支持全部测例，以及国内自主研发的LoongArch龙芯架构。不仅如此，该版本不支持网络协议，EXT4文件系统，以及其它多种多样的外设，因此我们认为，这个版本仍然有很大的优化空间。
如此，针对初赛和决赛阶段，我们的贡献可以总结为以下四点，并在后文中详细展开：
\begin{enumerate}
    \item 独自实现了2022版本的NPUcore到2k1000平台（龙芯架构）的适配，并封装为一个arch包，方便后人持续开发。
    \item 基本完成了NPUcore在ext4文件系统的适配，但仍有少部分bug。
    \item 调研了几乎所有的开源轻量版ext4仓库，并针对此次适配做了一定总结。
    \item 其它小规模增量：
    \begin{itemize}
        \item 在NPUcore-重生之我是菜狗队伍的指导下，适配了网络模块，并在fat32文件系统上跑出分数。（由于这个增量更多属于另一组，所以我们不会在此次文档中进行大面积介绍）
        \item 独自在ext4文件系统上适配了PCI和SATA驱动，可以从镜像中读取到测例。
        \item 对在2k1000板子上烧录测例进行了初步探索，并总结出了对应的步骤。
    \end{itemize}
\end{enumerate}

% \section{Rust特性}

% Rust是一个“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的程序设计风格的新型语言。
% Rust在完全公开的情况下开发，并且相当欢迎社区的反馈。近些年，Rust语言在工业应用上的势头越来越猛。
% 基于Rust语言的种种特性，我们认为它更适合一些底层应用的开发，尤其是OSKernel。

% \textbf{1. 我们为什么选择Rust作为OS编程语言？}
% Rust 是一门内存安全的语言。对于 C/C++ 这样的手动管理内存的编程语言，我们在分配堆变量的时候需要调用 malloc/new函数，而当该变量使用完毕之后要手动调用
% free/delete 回收内存。这就要求程序员需要关注所有堆变量的生命周期并及时将其释放，否则就会造成内存泄漏的问题，而过早的释放堆变量又可能造成“use-after-
% free” 的问题。而 Rust 独特的所有权机制和借用检查，让编译器掌管变量的生
% 命周期，使得变量的回收变得可控，同时也杜绝了”use-after-free” 的问题，又不至于带来垃圾回收的开销。

% Rust还能够推断出类型的大小，然后分配正确的内存大小并将其设置为您要求的值。但这意味着无法分配未初始化的内存：Rust没有null的概念。 
% 此外，所有这些检查都是在编译时完成的，因此没有运行时开销，这也是为什么Rust被成为是安全的“C”。 
% 如果你编写了正确的C++代码，你将编写出与C++代码基本上相同的Rust代码。而且由于编译器的帮忙，编写错误的代码版本是不可能的。
% 所以，我们选择Rust语言的原因，不仅是因为他安全，还因为其享有和C一样的速度，和更丰富的库。


% \textbf{2.unsafe关键字}

% 几乎每个语言都有unsafe关键字，但Rust语言使用unsafe的原因可能与其它编程语言还有所不同。接下来我们展示一下unsafe的特性：
% \begin{lstlisting}[language={Rust}, label={code:unsafe},
% 	caption={unsafe展示（r1 是一个裸指针）}]
% fn main() {
%     let mut num = 5;

%     let r1 = &num as *const i32;

%     unsafe {
%         println!("r1 is: {}", *r1);
%     }
% }
% \end{lstlisting}
% 在代码块\ref{code:unsafe}中，r1 是一个裸指针(raw pointer)，由于它具有破坏Rust内存安全的潜力，因此只能在unsafe代码块中使用，如果你去掉unsafe\{\}，编译器会立刻报错。
% 在我们的NPUcore中，对于一个OS来说，安全是最大的保障，因此unsafe在初期NPUcore建设中给予了很大帮助。因为，即使做到小心谨慎，依然会有出错的可能性，但是 unsafe 语句块决定了：就算内存访问出错了，你也能立刻意识到，错误是在 unsafe 代码块中，而不花大量时间像无头苍蝇一样去寻找问题所在。
% unsafe不安全，但是该用的时候就要用，在一些时候，它能帮助我们大幅降低代码实现的成本。虽然在网上充斥着“千万不要使用 unsafe，因为它不安全”的言论。事实上，我们认为unsafe是一个有效且必要的手段，因此我们选择遵循如下规则去使用：
% \begin{enumerate}
%     \item 没必要用时，就不用；
%     \item 当有必要用时，就大胆用，但是要控制好边界；
%     \item 尽量保证unsafe的边界范围最小。
% \end{enumerate}
