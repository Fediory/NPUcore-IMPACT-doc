\subsection{进程退出}

当一个进程完成自己的工作后，就需要调用exit进行“退出”以结束自己的生命周期。在xv6中，当一个子进程退出时它并不是直接死掉，而是将状态转变为Zombie。此后，当父进程调用wait时，将发现子进程可以退出，并由父进程负责释放子进程相关的内存空间。倘若父进程在子进程之前退出了，则由初始进程initproc接收子进程并负责它们退出。下面我们结合代码来阐述这一过程：

首先来看sys\_exit系统调用：

\begin{lstlisting}[language={Rust}, label={code:exit},
	caption={os/src/syscall/process.rs}]
pub fn sys_exit(exit_code: i32) -> ! {
	exit_current_and_run_next(exit_code);
	panic!("Unreachable in sys_exit!");
}
\end{lstlisting}

事实上，当应用调用sys\_exit系统调用主动退出，或是执行出错由内核终止之后，内核中都将调用exit\_current\_and\_run\_next函数退出当前进程并切换到下一个进程。

exit\_current\_and\_run\_next函数以一个退出码作为参数。当在sys\_exit系统调用中正常退出时，退出码由应用传到内核中；而对于出错退出的情况（例如访存错误、非法指令异常等），则是由内核指定一个特定的退出码（具体可在trap\_handler函数中查看）。最终，这个退出码会写入当前进程的TCB中，具体如下：

\begin{lstlisting}[language={Rust}, label={code:exit},
	caption={os/src/task/mod.rs}]
pub fn exit_current_and_run_next(exit_code: i32) {
	let task = take_current_task().unwrap();
	let mut inner = task.inner_exclusive_access();
	inner.task_status = TaskStatus::Zombie;
	inner.exit_code = exit_code;
	// ++++++ access initproc TCB exclusively
	{
		let mut initproc_inner = INITPROC.inner_exclusive_access();
		for child in inner.children.iter() {
			child.inner_exclusive_access().parent = Some(Arc::downgrade(&INITPROC));
			initproc_inner.children.push(child.clone());
		}
	}
	// ++++++ stop exclusively accessing parent PCB
	inner.children.clear();
	inner.memory_set.recycle_data_pages();
	drop(inner);
	// **** stop exclusively accessing current PCB
	drop(task);
	let mut _unused = TaskContext::zero_init();
	schedule(&mut _unused as *mut _);
}
\end{lstlisting}

第2行，我们从处理器监控PROCESSOR中取出而不是获取一个拷贝，这是为了正确维护TCB的引用计数。

第4行，我们将TCB中的状态改为为TaskStatus::Zombie即僵尸进程，令其后续被父进程在waitpid系统调用时进行回收。

第5行，我们将传入的退出码exit\_code写入TCB中，使后续父进程可以收集该退出码。

第7$\sim$13行，我们将当前进程的所有子进程挂在初始进程 initproc下面。做法是遍历当前进程的每个子进程，修改其父进程为初始进程，并把它们加入初始进程的子进程向量中。最后在第15行，我们将当前进程的子进程向量清空。

第16行，我们对当前进程占用的资源进行早期回收。我们调用了recycle\_data\_pages函数：

\begin{lstlisting}[language={Rust}, label={code:exit},
	caption={os/src/mm/memory\_set.rs}]
impl MemorySet {
	pub fn recycle_data_pages(&mut self) {
		self.areas.clear();
	}
}
\end{lstlisting}

注意该函数只是将地址空间中的逻辑段列表areas清空，从而使应用的地址空间被回收（即进程的数据段和代码段对应的物理页帧被回收）。然而用来存放页表的那些物理页帧此时还不会被回收，需要由父进程最后来回收子进程剩余的占用资源。

第21行，我们最后调用了schedule触发调度与任务切换，由于我们再也不会回到该进程的执行过程中，因此无需进行任务上下文的保存。

以上是子进程进行退出的过程，下面介绍父进程通过sys\_wait4系统调用来回收子进程资源的实现：

\begin{lstlisting}[language={Rust}, label={code:wait4},
	caption={os/src/syscall/process.rs}]
pub fn sys_wait4(pid: isize, status: *mut u32, option: u32, ru: *mut Rusage) -> isize {
	let option = WaitOption::from_bits(option).unwrap();
	info!("[sys_wait4] pid: {}, option: {:?}", pid, option);
	let task = current_task().unwrap();
	let token = task.get_user_token();
	loop {
		// find a child process
		
		// ---- hold current PCB lock
		let mut inner = task.acquire_inner_lock();
		if inner
			.children
			.iter()
			.find(|p| pid == -1 || pid as usize == p.getpid())
			.is_none()
		{
			return ECHILD;
			// ---- release current PCB lock
		}
		inner
			.children
			.iter()
			.filter(|p| pid == -1 || pid as usize == p.getpid())
			.for_each(|p| {
				trace!(
				"[sys_wait4] found child pid: {}, status: {:?}",
				p.pid.0,
				p.acquire_inner_lock().task_status
				)
			});
		let pair = inner.children.iter().enumerate().find(|(_, p)| {
			// ++++ temporarily hold child PCB lock
			p.acquire_inner_lock().is_zombie() && (pid == -1 || pid as usize == p.getpid())
			// ++++ release child PCB lock
		});
		if let Some((idx, _)) = pair {
			// drop last TCB of child
			let child = inner.children.remove(idx);
			trace!("[wait4] release zombie task, pid: {}", child.pid.0);
			// confirm that child will be deallocated after being removed from children list
			assert_eq!(Arc::strong_count(&child), 1);
			// if main thread exit
			if child.pid.0 == child.tgid {
				let found_pid = child.getpid();
				// ++++ temporarily hold child lock
				let exit_code = child.acquire_inner_lock().exit_code;
				// ++++ release child PCB lock
				if !status.is_null() {
					// this may NULL!!!
					match translated_refmut(token, status) {
						Ok(word) => *word = exit_code,
						Err(errno) => return errno,
					};
				}
				return found_pid as isize;
			}
		} else {
			drop(inner);
			if option.contains(WaitOption::WNOHANG) {
				return SUCCESS;
			} else {
				block_current_and_run_next();
				debug!("[sys_wait4] --resumed--");
			}
		}
	}
}
\end{lstlisting}

sys\_wait4函数的参数为指定进程的pid、可存储退出码的用户空间区域的指针status、函数执行方式的选项option、以及可存储进程资源占用信息的ru指针。

第11$\sim$19行，我们判断当前进程是否具有符合要求的子进程。当传入的pid为-1时，任何一个子进程都算是符合要求；但传入的pid不为-1的时候，则只有子进程的PID恰好与传入的pid相同时，才算符合条件。若没有符合条件的子进程，则函数直接返回ECHILD。

第20$\sim$36行，我们判断符合要求的子进程中是否有僵尸进程，若有，记录它在当前TCB子进程向量中的下标；若无，则进入第57~65行的处理.

第38行，我们将子进程从向量中移除并置于当前上下文中。

第41行，我们确认这是对于该子进程控制块的唯一一次强引用，即它不会出现在某个进程的子进程向量中，更不会出现在处理器监控器或者任务管理器中。当它所在的代码块结束，这次引用变量的生命周期结束，将导致该子进程进程控制块的引用计数变为0，彻底回收掉它占用的所有资源，包括其内核栈、PID还有应用地址空间存放页表的那些物理页帧等。

第43$\sim$56行，我们将收集的子进程信息进行返回，包括退出码等，最后以回收的子进程PID作为函数返回值返回。

第57$\sim$65行，是对于没有可回收的子进程的情况的处理。倘若函数选项参数option具有WNOHANG标志，则说明调用该函数的进程不会被挂起，返回SUCCESS继续执行；若无该标志，则会切换至下一个进程执行。

至此，父进程对子进程的回收机制也介绍完毕。下面我们最后再介绍一个进程的退出机制：kill。

如果说exit机制是一个进程的“自杀”，则kill机制使得一个进程可以“杀死”其他进程。我们来看具体实现：

\begin{lstlisting}[language={Rust}, label={code:kill},
	caption={os/src/syscall/process.rs}]
pub fn sys_kill(pid: usize, sig: usize) -> isize {
	let signal = match Signals::from_signum(sig) {
		Ok(signal) => signal,
		Err(_) => return EINVAL,
	};
	if pid > 0 {
		if let Some(task) = find_task_by_tgid(pid) {
			if !signal.is_empty() {
				let mut inner = task.acquire_inner_lock();
				inner.add_signal(signal);
				// wake up target process if it is sleeping
				if inner.task_status == TaskStatus::Interruptible {
					inner.task_status = TaskStatus::Ready;
					drop(inner);
					wake_interruptible(task);
				}
			}
			SUCCESS
		} else {
			ESRCH
		}
	} else if pid == 0 {
		todo!()
	} else if (pid as isize) == -1 {
		todo!()
	} else { // (pid as isize) < -1
		todo!()
	}
}
\end{lstlisting}

事实上，sys\_kill系统调用的实现非常简单。该函数有两个参数，一个是目的进程的pid，一个是将给目的进程赋予的信号sig。kill机制的实现实际上就是找出要“杀死”的进程，并给它赋予一个信号量，该信号可以为“自杀”的信号，然后再将该进程唤醒，让其自我终结。

第6$\sim$21行，就是先使用find\_task\_by\_tgid函数来找出目的进程，若有，则为其赋予一个指定的信号，然后再将该进程从阻塞态唤醒，然后返回SUCCESS；若无，则返回ESRCH代表未找到目的进程。

如你所见，本系统调用仅是kill机制的初步实现，还未最终完善。