\subsection{进程创建}
execve 被用于替换当前进程的地址空间和上下文为新程序的，新程序将取代原程序执行。如果 execve 执行成功，原程序的代码和数据将被替换为新程序的代码和数据，并开始执行新程序。
filename：要执行的新程序的文件路径。
argv：参数数组，用于传递给新程序的命令行参数。
envp：环境变量数组，用于设置新程序的环境变量。
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    pub fn sys_execve(
        pathname: *const u8,
        mut argv: *const *const u8,
        mut envp: *const *const u8,
    ) -> isize {}
\end{lstlisting}
在NPUcore中，若需要创建一个新的进程，总体上的过程和方法如下所示：

（1）从系统文件中找到内核加载第一个初始进程的elf文件，获取代码的数据和内容。然后调用TCB中的new()方法创建内核的第一个进程initproc。

（2）其余所有的进程均由初始进程initproc进行fork而来，初始进程initproc是所有进程的父进程。因此创建新进程的第二步便是调用fork系统调用

（3）在调用fork后，新的进程还需要加载独立的程序代码和数据文件，这时便需要用到exec系统调用。
##### sys_exec()

exec()的作用：

fork通常只创建现有进程的拷贝
exec可以在现有fork的基础上加载一个新应用的 ELF 可执行文件中的代码和数据替换原有的应用地址空间中的内容，并开始执行。

1.首先看函数的输入参数与返回值
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    pub fn sys_execve(
        pathname: *const u8,
        mut argv: *const *const u8,
        mut envp: *const *const u8,
    ) -> isize {
        //load_elf 成功
        SUCCESS
        //失败
        Err
    }
\end{lstlisting}
2.将argv和envp变量字符串向量，通过循环，将*const *const u8转为Vec<String>数据类型。为后面的执行做准备。
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let mut argv_vec: Vec<String> = Vec::with_capacity(16);
    let mut envp_vec: Vec<String> = Vec::with_capacity(16);
    if !argv.is_null() {
        loop {
            let arg_ptr = match translated_ref(token, argv) {
                Ok(argv) => *argv,
                Err(errno) => return errno,
            };
            if arg_ptr.is_null() {
                break;
            }
            argv_vec.push(match translated_str(token, arg_ptr) {
                Ok(arg) => arg,
                Err(errno) => return errno,
            });
            unsafe {
                argv = argv.add(1);
            }
        }
    }
    if !envp.is_null() {
        loop {
            let env_ptr = match translated_ref(token, envp) {
                Ok(envp) => *envp,
                Err(errno) => return errno,
            };
            if env_ptr.is_null() {
                break;
            }
            envp_vec.push(match translated_str(token, env_ptr) {
                Ok(env) => env,
                Err(errno) => return errno,
            });
            unsafe {
                envp = envp.add(1);
            }
        }
    }


\end{lstlisting}
3.debug 层信息输出
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    debug!(
        "[exec] argv: {:?} /* {} vars */, envp: {:?} /* {} vars */",
        argv_vec,
        argv_vec.len(),
        envp_vec,
        envp_vec.len()
    );
  \end{lstlisting}
4.准备将 ELF 文件的内容载入当前进程
要对读取的文件做以下检查
    1、文件大小大于等于 4
    2、同时，ELF文件以 4 位魔数"\x7fELF"开头，因此应检查文件首是否有此魔数。
\begin{lstlisting}[language={Rust}, label={code:forktest},
        caption={forktest.rs}]
        match working_inode.open(&path, OpenFlags::O_RDONLY, false) {
            Ok(file) => {
                if file.get_size() < 4 {
                    return ENOEXEC;
                }
                let mut magic_number = Box::<[u8; 4]>::new([0; 4]);
                // this operation may be expensive... I'm not sure
                file.read(Some(&mut 0usize), magic_number.as_mut_slice());
                let elf = match magic_number.as_slice() {
                    b"\x7fELF" => file,
                    b"#!" => {
                        let shell_file = working_inode
                            .open(DEFAULT_SHELL, OpenFlags::O_RDONLY, false)
                            .unwrap();
                        argv_vec.insert(0, DEFAULT_SHELL.to_string());
                        shell_file
                    }
                    _ => return ENOEXEC,
                };
    
                
\end{lstlisting}
5.真正的载入过程。loaf_elf将当前的elf文件内容覆盖当前的进程。
show_frame_consumption!宏输出对应的信息

\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let task = current_task().unwrap();
    show_frame_consumption! {
        "load_elf";
        if let Err(errno) = task.load_elf(elf, &argv_vec, &envp_vec) {
            return errno;
        };
    }
    // should return 0 in success
    SUCCESS
}
Err(errno) => errno,
}
\end{lstlisting}

clone()
从linux 2.3.3开始，glibc的`fork()`封装作为NPTL(Native POSIX Threads Library)线程实现的一部分。直接调用`fork()`等效于调用[clone(2)](https://man7.org/linux/man-pages/man2/clone.2.html)时仅指定`flags`为`SIGCHLD`(共享信号句柄表)。

创建线程的函数`pthread_create`内部使用的也是clone函数。在glibc的`/sysdeps/unix/sysv/linux/createthread.c`源码中可以看到，创建线程的函数`create_thread`中使用了clone函数，并指定了相关的`flags`：
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    const int clone_flags = (CLONE_VM | CLONE_FS 
    | CLONE_FILES | CLONE_SYSVSEM 
    | CLONE_SIGHAND | CLONE_THREAD 
    | CLONE_SETTLS | CLONE_PARENT_SETTID 
    | CLONE_CHILD_CLEARTID | 0);
  \end{lstlisting}
同样，npucore中的`clone`也使用了这种模式，以这两种方式来创建进程和线程

clone的使用
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    pub fn sys_clone(
        flags: u32,
        stack: *const u8,
        ptid: *mut u32,
        tls: usize,
        ctid: *mut u32,
    ) -> isize
  \end{lstlisting}
描述
该系统调用用于创建一个新的子进程，类似fork(2)。与fork(2)相比，它可以更精确地控制调用进程和子
进程之间的执行上下文细节。例如，使用这些系统调用，调用者可以控制两个进程之间是否共享虚拟地
址空间，文件描述符表以及信号句柄表等。也可以通过这些系统调用将子进程放到不同的命名空间中。
参数
flags:
包括 CloneFlags 和 exit_signal 两部分 ：
子进程结束信号 exit_signal
当子进程退出时，会像父进程发送一个信号。退出信号在 clone() 的 flags 的低字节中指定如果该信
号不是 SIGCHLD ，那么父进程在使用wait(2)等待子进程退出时必须指定 __WALL 或WCLONE选项。如
果没有指定任何信号(即，0)，则在子进程退出后不会向父进程发送任何信号。
以下是npucore中如何从 flags 中获取子进程结束信号的代码块
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let exit_signal = match Signals::from_signum((flags & 0xff) as usize) {
        Ok(signal) => signal,
        Err(_) => {
            warn!(
                "[sys_clone] signum of exit_signal is unspecified or invalid: {}",
                (flags & 0xff) as usize
            );
            // This is permitted by standard, but we only support 64 signals
            Signals::empty()
        }
    };
  \end{lstlisting}
CloneFlags
CloneFlags 用来指定 clone 系统调用的行为，npucore的 CloneFlags 中有如下几种值
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    bitflags! {
        pub struct CloneFlags: u32 {
            //const CLONE_NEWTIME         =   0x00000080;
            const CLONE_VM              =   0x00000100;
            const CLONE_FS              =   0x00000200;
            const CLONE_FILES           =   0x00000400;
            const CLONE_SIGHAND         =   0x00000800;
            const CLONE_PIDFD           =   0x00001000;
            const CLONE_PTRACE          =   0x00002000;
            const CLONE_VFORK           =   0x00004000;
            const CLONE_PARENT          =   0x00008000;
            const CLONE_THREAD          =   0x00010000;
            const CLONE_NEWNS           =   0x00020000;
            const CLONE_SYSVSEM         =   0x00040000;
            const CLONE_SETTLS          =   0x00080000;
            const CLONE_PARENT_SETTID   =   0x00100000;
            const CLONE_CHILD_CLEARTID  =   0x00200000;
            const CLONE_DETACHED        =   0x00400000;
            const CLONE_UNTRACED        =   0x00800000;
            const CLONE_CHILD_SETTID    =   0x01000000;
            const CLONE_NEWCGROUP       =   0x02000000;
            const CLONE_NEWUTS          =   0x04000000;
            const CLONE_NEWIPC          =   0x08000000;
            const CLONE_NEWUSER         =   0x10000000;
            const CLONE_NEWPID          =   0x20000000;
            const CLONE_NEWNET          =   0x40000000;
            const CLONE_IO              =   0x80000000;
        }
    }
  \end{lstlisting}
下文将介绍几个和传入参数有关的 cloneflags
stack：
stack 参数指定了子进程使用的栈的位置。由于子进程和调用进程可能会共享内存，因此不能在调用进
程的栈中运行子进程。调用进程必须为子进程的栈配置内存空间，并向 clone() 传入一个执行该空间的
指针。运行的所有处理器的栈都是向下生长的，因此 stack 通常指向为子进程栈设置的内存空间的最顶
端地址。注意， clone() 没有为调用者提供一种可以将堆栈区域的大小通知内核的方法。

ptid，ctid：
与 CloneFlags 中的 CLONE_CHILD_SETTID 和 CLONE_PARENT_SETTID 有关
CLONE_CHILD_SETTID
在ctid的位置上保存线程ID。保存操作会在 clone 调用返回控制到子进程的用户空间前完成。(注意，在
clone调用返回父进程前，保存操作可能是未完成的，它与是否引入 CLONE_VM 标志相关)
CLONE_PARENT_SETTID
在父进程的ptid中保存子线程ID。在Linux 2.5.32-2.5.48版本中，有一个标志 CLONE_SETTID 做了同样
的事情。保存操作会在clone调用将控制返回给用户空间前完成。
tid：
与 CloneFlags 中的 CLONE_SETTLS 有关
CLONE_SETTLS
将TLS(Thread Local Storage)保存到 tls 字段中。
npucore中clone的具体实现
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let child = parent.sys_clone(flags, stack, tls, exit_signal);
  \end{lstlisting}
npucore中clone的具体实现实际是实现在TCB结构体的方法 sys_clone 里，这里就是调用了
parent（也就是clone的调用者）的sys_clone，它返回新创建的进程的TCB结构体
首先， clone 会检查 CloneFlags 中是否有 CLONE_VM 和 CLONE_THREAD
如果有 CLONE_VM ，则调用进程和子进程会运行在系统的同一个内存空间中。调用进程或子进程对内存
的写操作都可以被对方看到。如果没有设置 CLONE_VM ，则子进程会运行在执行clone时的调用进程的
一份内存空间的拷贝中。
如果有 CLONE_THREAD ，子线程会放到与调用进程相同的线程组中。当一个 clone 调用没有指定
CLONE_THREAD 时，生成的线程会放到一个新的线程组中，其TGID等于该线程的TID
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let memory_set = if flags.contains(CloneFlags::CLONE_VM) {
        self.vm.clone()
    } else {
        crate::mm::frame_reserve(16);
        Arc::new(Mutex::new(MemorySet::from_existing_user(
            &mut self.vm.lock(),
        )))
    };
    
    let tid_allocator = if flags.contains(CloneFlags::CLONE_THREAD) {
        self.tid_allocator.clone()
    } else {
        Arc::new(Mutex::new(RecycleAllocator::new()))
    };
    
    // 这里改变了源代码的顺序，此处的tid实为下文声明的
    if flags.contains(CloneFlags::CLONE_THREAD) {
        memory_set.lock().alloc_user_res(tid, stack.is_null());
    }
  \end{lstlisting}
接着clone会像操作系统申请pid，tid，tgid和内核栈，因为npucore模仿了linux的“以轻量级进程代替
线程”，所以这里的pid与tid相同，为线程号，而tgid代表该进程的进程号
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    // alloc a pid and a kernel stack in kernel space
    let pid_handle = pid_alloc();
    let tid = tid_allocator.lock().alloc();
    let tgid = if flags.contains(CloneFlags::CLONE_THREAD) {
        self.tgid
    } else {
        pid_handle.0
    };
    let kstack = kstack_alloc();
    let kstack_top = kstack.get_top();
    
  \end{lstlisting}
然后clone会进行新进程TCB的构造
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let task_control_block = Arc::new(TaskControlBlock {
        pid: pid_handle,
        tid,
        tgid,
        kstack,
        ustack_base: if !stack.is_null() {
            stack as usize
        } else {
            ustack_bottom_from_tid(tid)
        },
        exit_signal,
        exe: self.exe.clone(),
        tid_allocator,
        files: if flags.contains(CloneFlags::CLONE_FILES) {
            self.files.clone()
        } else {
            Arc::new(Mutex::new(self.files.lock().clone()))
        },
        fs: if flags.contains(CloneFlags::CLONE_FS) {
            self.fs.clone()
        } else {
            Arc::new(Mutex::new(self.fs.lock().clone()))
        },
        vm: memory_set,
        sighand: if flags.contains(CloneFlags::CLONE_SIGHAND) {
            self.sighand.clone()
        } else {
            Arc::new(Mutex::new(self.sighand.lock().clone()))
        },
        futex: if flags.contains(CloneFlags::CLONE_SYSVSEM) {
            self.futex.clone()
        } else {
            // maybe should do clone here?
            Arc::new(Mutex::new(Futex::new()))
        },
        inner: Mutex::new(TaskControlBlockInner {
            // inherited
            pgid: parent_inner.pgid,
            heap_bottom: parent_inner.heap_bottom,
            heap_pt: parent_inner.heap_pt,
            // clone
            sigpending: parent_inner.sigpending.clone(),
            // new
            children: Vec::new(),
            rusage: Rusage::new(),
            clock: ProcClock::new(),
            clear_child_tid: 0,
            robust_list: RobustList::default(),
            timer: [ITimerVal::new(); 3],
            sigmask: Signals::empty(),
            // compute
            trap_cx_ppn,
            task_cx: TaskContext::goto_trap_return(kstack_top),
            parent: if flags.contains(CloneFlags::CLONE_PARENT)
                | flags.contains(CloneFlags::CLONE_THREAD)
            {
                parent_inner.parent.clone()
            } else {
                Some(Arc::downgrade(self))
            },
            // constants
            task_status: TaskStatus::Ready,
            exit_code: 0,
        }),
    });
  \end{lstlisting}
这里对相关 CloneFlags 进行说明
CLONE_FILES 子进程与父进程共享相同的文件描述符（file descriptor）表
CLONE_FS 子进程与父进程共享相同的文件系统，包括root、当前目录、umask
CLONE_SIGHAND 子进程与父进程共享相同的信号处理（signal handler）表
CLONE_SYSVSEM 如果设置了该标志，则子进程和调用进程会共享一组System V semaphore
adjustment (semadj) 值(参见semop(2))。这种情况下，共享列表会在共享该列表的所有进程之间累加
semadj 值，并且仅当共享列表的最后一个进程终止（或使用unshare(2)停止共享列表）时才会执行
semaphore adjustments。如果没有设置该标志，则子进程会有一个独立的 semadj 列表，且初始为
空。
与信号量操作有关。
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    files: if flags.contains(CloneFlags::CLONE_FILES) {
        self.files.clone()
    } else {
        Arc::new(Mutex::new(self.files.lock().clone()))
    },
    
    
    fs: if flags.contains(CloneFlags::CLONE_FS) {
        self.fs.clone()
    } else {
        Arc::new(Mutex::new(self.fs.lock().clone()))
    },
    
    
    sighand: if flags.contains(CloneFlags::CLONE_SIGHAND) {
            self.sighand.clone()
        } else {
            Arc::new(Mutex::new(self.sighand.lock().clone()))
        },
    
    
    futex: if flags.contains(CloneFlags::CLONE_SYSVSEM) {
        self.futex.clone()
    } else {
        // maybe should do clone here?
        Arc::new(Mutex::new(Futex::new()))
    },
  \end{lstlisting}
这里会修改父进程的子进程表，如果设置了 CLONE_PARENT 或 CLONE_THREAD 则代表新建进程与调用进
程是兄弟关系，反之则调用进程是新建进程的父进程
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    // add child
    if flags.contains(CloneFlags::CLONE_PARENT) || flags.contains(CloneFlags::CLONE_THREAD) {
        if let Some(grandparent) = &parent_inner.parent {
            grandparent
                .upgrade()
                .unwrap()
                .acquire_inner_lock()
                .children
                .push(task_control_block.clone());
        }
    } else {
        parent_inner.children.push(task_control_block.clone());
    }
  \end{lstlisting}
最后， clone 会设置新进程的上下文以及tls并返回
\begin{lstlisting}[language={Rust}, label={code:forktest},
    caption={forktest.rs}]
    let trap_cx = task_control_block.acquire_inner_lock().get_trap_cx();
    if flags.contains(CloneFlags::CLONE_THREAD) {
        *trap_cx = *parent_inner.get_trap_cx();
    }
    // we also do not need to prepare parameters on stack, musl has done it for us
    if !stack.is_null() {
        trap_cx.gp.sp = stack as usize;
    }
    // set tp
    if flags.contains(CloneFlags::CLONE_SETTLS) {
        trap_cx.gp.tp = tls;
    }
    // for child process, fork returns 0
    trap_cx.gp.a0 = 0;
    // modify kernel_sp in trap_cx
    trap_cx.kernel_sp = kstack_top;
    // return
    task_control_block
\end{lstlisting}