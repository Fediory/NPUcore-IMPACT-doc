\section{支持运行Lmbench}
\begin{table}[!ht]
   	\centering
   	\begin{tabular}{|c|c|c|c|c|}
   		\hline
   		\textbf{方法} & \textbf{运行环境} & \textbf{对象} & \textbf{结果} & \textbf{原理} \\
   		\hline
   		objdump+grep & Linux & 二进制文件 & 测例的所有系统调用 & 参见chapter09-03 \\ \hline
   		strace & Debian+RISCV64 & 运行的进程 & 单个测例的系统调用 &  参见chapter10-02 \\
   		\hline
   	\end{tabular}
   	\caption{提取系统调用的方法}
   	\label{提取系统调用的方法}
   \end{table}
要从lmbench二进制文件中提取出相关的系统调用，过程基本与提取busybox的系统调用类似。
仍然可以用一行命令完成。

\begin{lstlisting}[language=bash]
    # 从二进制文件中获取系统调用号，将objfile改为提取的目标二进制文件
    objdump -d objfile | grep -B 9 ecall | grep "li.a7" | tee syscall.txt

    # 如果报错：objdump: can't disassemble for architecture UNKNOWN! ，是由于当前的objdump并非RISC-V架构，尝试
    riscv64-linux-gnu-objdump -d busybox | grep -B 9 ecall | grep "li.a7" | tee syscall.txt

\end{lstlisting}

上述命令的详细解释，请参考第九章第三节，在此不再赘述。

而在实际情况中，还可能出现需要查看某条命令调用系统调用的情况，而反汇编并提取系统调用的方式，粒度过大，无法满足我们的要求。
以lmbench为例，给出两种可能的查看系统调用的方法。

第一种，阅读lmbench的源代码。lmbench的入口在 ~/testsuits-for-oskernel/lmbench/src 文件夹下的 lmbench_all.c 中。这种方法极其繁琐复杂，不推荐。

我们推荐使用第二种方法，也就是利用strace工具捕捉程序运行时调用的系统调用。
strace 是一个用于 Linux 的诊断、调试和指导用户空间实用程序。它用于监视和篡改进程与 Linux 内核之间的交互，包括系统调用、信号传递和进程状态的更改。


\begin{lstlisting}[language=bash]
    # 提取出一条指令使用的系统调用，并以摘要形式给出系统调用列表。注意执行环境为QEMU（RISCV64+Debian）
     strace -c -f -e trace=all -o trace_output.txt <命令>
\end{lstlisting}

例如，对于 lmbench 检测 write 系统调用性能的命令 lmbench_all lat_syscall -P 1 write ，可以使用如下指令。

\begin{lstlisting}[language=bash]
      strace -c -f -e trace=all -o trace_output.txt ./lmbench_all lat_syscall -P 1 write
\end{lstlisting}

执行结果如下，会给出系统调用的列表。
\begin{lstlisting}[language=bash]
	root@debian:~/20231228# cat trace_output.txt
	% time     seconds  usecs/call     calls    errors syscall
	------ ----------- ----------- --------- --------- ----------------
	 58.11    0.044731       44731         1           wait4
	 28.03    0.021578          47       452           write
	  5.78    0.004450          13       332           getrusage
	  3.72    0.002864        2864         1           execve
	  0.73    0.000562          43        13           close
	  0.72    0.000558         558         1           readlinkat
	  0.67    0.000515          85         6           pselect6
	  0.64    0.000492          30        16           getppid
	  0.42    0.000320          53         6           read
	  0.34    0.000258          32         8           rt_sigaction
	  0.26    0.000200          50         4           brk
	  0.19    0.000150         150         1           openat
	  0.18    0.000140          70         2           setitimer
	  0.16    0.000121         121         1           mprotect
	  0.05    0.000040          40         1           uname
	  0.00    0.000000           0         4           pipe2
	  0.00    0.000000           0         1           clone
	------ ----------- ----------- --------- --------- ----------------
	100.00    0.076979          90       850           total
\end{lstlisting}

针对无法编译得到lmbench可执行文件的问题，我们可以利用大赛发布的SD卡镜像，将其挂载到我们的目录下，在此给出相关命令。

\begin{lstlisting}[language=bash]
     	mkdir mnt
	# 挂载到mnt下
	sudo mount -o loop sdcard.img mnt
	# 使用完之后，取消挂载
	umount mnt
\end{lstlisting}


在本节中，我们通过比较得到Lmbench中存在\textbf{17}条完全不同于Busybox中的系统调用。

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{指令} & \textbf{系统调用} & \textbf{系统调用号} \\
\hline
li a7,101 & \_\_NR\_nanosleep & 101 \\
\hline
li a7,114 & \_\_NR\_clock\_getres & 114 \\
\hline
li a7,118 & \_\_NR\_sched\_setparam & 118 \\
\hline
li a7,119 & \_\_NR\_sched\_setscheduler & 119 \\
\hline
li a7,120 & \_\_NR\_sched\_getscheduler & 120 \\
\hline
li a7,121 & \_\_NR\_sched\_getparam & 121 \\
\hline
li a7,131 & \_\_NR\_tgkill & 131 \\
\hline
li a7,165 & \_\_NR\_getrusage & 165 \\
\hline
li a7,202 & \_\_NR\_accept & 202 \\
\hline
li a7,203 & \_\_NR\_connect & 203 \\
\hline
li a7,206 & \_\_NR\_sendto & 206 \\
\hline
li a7,207 & \_\_NR\_recvfrom & 207 \\
\hline
li a7,211 & \_\_NR\_sendmsg & 211 \\
\hline
li a7,212 & \_\_NR\_recvmsg & 212 \\
\hline
li a7,227 & \_\_NR\_msync & 227 \\
\hline
li a7,72 & \_\_NR\_pselect6 & 72 \\
\hline
li a7,82 & \_\_NR\_fsync & 82 \\
\hline
\end{tabular}
\caption{Lmbench系统调用}
\end{table}

针对这些系统调用，我们将其分为了以下\textbf{7}种类型：

\begin{itemize}
    \item \textbf{时间和定时器相关系统调用}

    \item \textbf{进程调度和管理系统调用}

    \item \textbf{信号和线程管理系统调用}

    \item \textbf{资源和性能监测系统调用}

    \item \textbf{网络编程相关系统调用}

    \item \textbf{文件操作和数据同步系统调用}

    \item \textbf{事件等待和选择系统调用}
\end{itemize}

接下来，我们将分类为大家讲解各个类别的系统调用功能。

\begin{itemize}
    \item \textbf{时间和定时器相关系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_nanosleep (101)}: 用于导致当前进程休眠指定的时间，通常用于实现定时器功能。
        \item \texttt{\_\_NR\_clock\_getres (114)}: 用于获取指定时钟的分辨率（精度），可以用于测量时间间隔。
    \end{itemize}

    \item \textbf{进程调度和管理系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_sched\_setparam (118)}: 用于设置指定进程的调度参数，例如设置进程的优先级等。
        \item \texttt{\_\_NR\_sched\_setscheduler (119)}: 用于设置指定进程的调度策略，例如设置为实时调度或普通调度。
        \item \texttt{\_\_NR\_sched\_getscheduler (120)}: 用于获取指定进程的当前调度策略。
        \item \texttt{\_\_NR\_sched\_getparam (121)}: 用于获取指定进程的调度参数，例如获取进程的优先级等。
    \end{itemize}

    \item \textbf{信号和线程管理系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_tgkill (131)}: 用于向指定线程组（thread group）中的线程发送信号。
    \end{itemize}

    \item \textbf{资源和性能监测系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_getrusage (165)}: 用于获取进程或子进程的资源使用情况，如CPU时间、内存使用等信息。
    \end{itemize}

    \item \textbf{网络编程相关系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_accept (202)}: 用于在网络编程中接受来自客户端的连接请求。
        \item \texttt{\_\_NR\_connect (203)}: 用于在网络编程中建立与远程服务器的连接。
        \item \texttt{\_\_NR\_sendto (206)}: 用于在网络编程中向指定目标发送数据。
        \item \texttt{\_\_NR\_recvfrom (207)}: 用于在网络编程中从指定源接收数据。
        \item \texttt{\_\_NR\_sendmsg (211)}: 用于发送消息，通常用于进程间通信（IPC）。
        \item \texttt{\_\_NR\_recvmsg (212)}: 用于接收消息，通常用于进程间通信（IPC）。
    \end{itemize}

    \item \textbf{文件操作和数据同步系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_msync (227)}: 用于将内存中的数据同步到文件中，通常用于文件映射。
        \item \texttt{\_\_NR\_fsync (82)}: 用于将指定文件的数据和元数据刷新到磁盘上，以确保数据持久化。
    \end{itemize}

    \item \textbf{事件等待和选择系统调用}
    \begin{itemize}
        \item \texttt{\_\_NR\_pselect6 (72)}: 用于在多个文件描述符上等待事件，并在事件发生时返回。
    \end{itemize}
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\textbf{系统调用类别} & \textbf{系统调用} & \textbf{系统调用号} \\
\hline
时间和定时器相关 & \_\_NR\_nanosleep & 101 \\
& \_\_NR\_clock\_getres & 114 \\
\hline
进程调度和管理 & \_\_NR\_sched\_setparam & 118 \\
& \_\_NR\_sched\_setscheduler & 119 \\
& \_\_NR\_sched\_getscheduler & 120 \\
& \_\_NR\_sched\_getparam & 121 \\
\hline
信号和线程管理 & \_\_NR\_tgkill & 131 \\
\hline
资源和性能监测 & \_\_NR\_getrusage & 165 \\
\hline
网络编程相关 & \_\_NR\_accept & 202 \\
& \_\_NR\_connect & 203 \\
& \_\_NR\_sendto & 206 \\
& \_\_NR\_recvfrom & 207 \\
& \_\_NR\_sendmsg & 211 \\
& \_\_NR\_recvmsg & 212 \\
\hline
文件操作和数据同步 & \_\_NR\_msync & 227 \\
& \_\_NR\_fsync & 82 \\
\hline
事件等待和选择 & \_\_NR\_pselect6 & 72 \\
\hline
\end{tabular}
\caption{Lmbench分类系统调用}
\end{table}
